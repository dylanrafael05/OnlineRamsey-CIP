	This document will explain how Painter and Builder strategies work in our Online Ramsey program.  First of all, every strategy in our game inherits from the "IPlayer" interface (Scripts -> Gameplayer -> Strategy -> Strategy.cs).  Painter and Builder strategies implement IPlayer's GetMove method and return moves of type "IMove".  To distinguish them, we have two structs: PainterMove and BuilderMove.  They both inherit from IMove.  Additionally, Painter and Builder strategies don't directly inherit from IPlayer, they inherit from the abstract classes "Painter" and "Builder".  These abstract classes force implementation of GetMove methods that return PainterMove and BuilderMove respectively.  This is a bit more info than you may need: all you need to know is that Painter strategies must inherit from the Painter abstract class and implement a GetMove method that returns PainterMove.  Builder Strategies must inherit from the Builder abstract class and implement a GetMove method that returns BuilderMove.  GetMove also takes in a GameState (Scripts -> Board -> GameState.cs) object, which contains the current state of the board and some helper methods that can help with some strategies.  In addition, for Builder strategies, we also have the BuilderUtils static class (Scripts -> Gameplayer -> Builder Helper -> BuilderUtils.cs), which implements a few methods that could be helpful in some Builder strategies.
	Since a lot of Builder strategies have logic that isn't ephemeral, instead opting to follow a tree of possibilities based on each Painter move, we've made a class for that.  Instead of GetMove simply being a function of the current state of the board that returns a BuilderMove, it's now 1 step in the Builder's overall dynamic sequence (that can change depending on painter moves).  We've simplified this further: since, technically, the game can go on infinitely, the finite sequence Builder has must loop.  This works out very well since most of the strategies that would benefit from using the sequence also follow a sort of loop.  For example, the Cap Builder strategy, the one that will complete a game in under 4n-6 moves, (where n is the length of the path needed to win the game) follows a loop sequence that starts with the longest red and blue path.  It executes its plan, which may change slightly due to painter moves, and then loops again with a red and blue path, longer than the one it started with last loop.  Additionally, sometimes we may also need and initial sequence that sets everything up for the loop sequence.
	Our implementation of this sequence system uses IEnumerables and a SequenceNavigator object.  The IEnumerable can be seen as a function that can return its result and then pause, waiting to be called again, at which point it will resume until the next return point, where it will pause again.  In this case, GetMove will call the IEnumerable, which will take in the state of the board, from which it will garner what painter just did, and will return a BuilderMove.  The SequenceNavigator object abstracts this further: you construct the object with a list of IEnumerables.  When you call the Loop method of the SequenceNavigator, it'll call its current IEnumerable (which, at the start, will be the first IEnumerable you pass in).  After a few function calls, the first IEnumerable you passed in will finish, at which point it will go onto the next one.  This will continue until the last IEnumerable, which it will loop.  Once it finishes the last IEnumerable it will go back to the beginning of the last IEnumerable.  This way, we can initialize our SequenceNavigator with an InitialEnumerable and a LoopEnumerable.  It will automatically loop the last Enumerable passed in, so this works out.
	Returned moves will be executed by inner parts of our code after the strategy returns the move.  BuilderMoves are comprised of two nodes.  PainterMoves are comprised of an edge object and the color it should be painted (0 or 1 represented by an integer).  Our system will have a Builder and Painter strategy object at hand (depending on the selection you make in the main menu), and after calling GetMove, will check if the returns move is valid, (IsValid in Move.cs) and will execute the move if it is.  Then, it'll simply do the same thing with the other player.  It'll get a Painter move, then a Builder move, then a Painter move... etc.  If the move isn't valid, however, it'll instead try to run GetMove on the same player again.  If Builder returns a move that isn't valid (ie. an edge between two nodes that are already connected), then the system will simply call the Builder's GetMove again, hoping that it returns a valid move this time.
	*INSERT PARAGRAPH EXPLAINING THAT YOU HAVE TO PUT A STATIC CONSTRUCTOR AND HOW TO USE THE STRATEGY INITIALIZER SYSTEM FOR YOUR PARAMETERS*

Important files/folders to look at regarding the information in this document:
	GameState.cs (Scripts -> Board -> GameState.cs)
	Strategy.cs (Scripts -> Gameplayer -> Strategy -> Strategy.cs)
	Move.cs (Scripts -> Gameplayer -> Strategy -> Move.cs)
	BuilderUtils.cs (Scripts -> Gameplayer -> Computer Player -> BuilderUtils.cs)
	Builder Strategies (Scripts -> Gameplayer -> Computer Player -> Builder Strategies)
	Painter Strategies (Scripts -> Gameplayer -> Computer Player -> Painter Strategies)